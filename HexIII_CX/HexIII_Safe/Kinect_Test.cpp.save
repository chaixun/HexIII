#include "Kinect_Test.h"

int Kinect::ControlCommand;
bool Kinect::IsCaptureEnd;

Kinect::Kinect():interface(new pcl::OpenNIGrabber())
{
    IsCapture = false;
    IsCaptureEnd = false;
    Kinect::ControlCommand = NoValidCommand;
    frames_num = 0;
}
Kinect::~Kinect()
{

}

void Kinect::start()
{
    interface->start();
    cout<<"Depth Open"<<endl;
}

void Kinect::capture(int *num)
{
    (*num)++;
    frames_num++;
    IsCapture = true;
    cout<<"Capture Step "<<*num<<" Beging !!!"<<endl;
}

void Kinect::pointcloud(const pcl::PointCloud<pcl::PointXYZ>::ConstPtr &cloud)
{
    if (IsCapture == true)
    {
        bool Obstacle = false;
        IsCapture = false;
        pcl::PointCloud<pcl::PointXYZ>::Ptr SensorPoint(new pcl::PointCloud<pcl::PointXYZ>);

        Eigen::Matrix4f transformation1;
        transformation1 << -1, 0, 0, 0,
                0, -1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1;
        pcl::transformPointCloud(*cloud,*SensorPoint,transformation1);

        pcl::PointCloud<pcl::PointXYZ>::Ptr RobotPoint(new pcl::PointCloud<pcl::PointXYZ>);
        Eigen::Matrix4f transformation2;
        transformation2 << 0.9995, 0.0236, -0.0199, 0.0223+0.02,
                -0.0308, 0.7192, -0.6941, 0.1997+0.85+0.035,
                -0.0021, 0.6944, 0.7196, 0.5624+0.05,
                0, 0, 0, 1;
        //                transformation2 << 1, 0, 0, 0,
        //                        0, 1, 0, 0.73,
        //                        0, 0, 1, 0,
        //                        0, 0, 0, 1;
        pcl::transformPointCloud(*SensorPoint,*RobotPoint,transformation2);


        //Mapping GridMap
        Eigen::MatrixXf GridMap = Eigen::MatrixXf::Zero(120,120);
        Eigen::MatrixXf GridNum = Eigen::MatrixXf::Zero(120,120);
        for (size_t i = 0;i < RobotPoint->points.size(); ++i)
        {
            if(RobotPoint->points[i].x>-1.5&&RobotPoint->points[i].x<1.5&&
                    RobotPoint->points[i].z>0&&RobotPoint->points[i].z<3&&
                    RobotPoint->points[i].y>0)
            {
                int m, n;
                n = floor(RobotPoint->points[i].x/0.025) + 60;
                m = floor(RobotPoint->points[i].z/0.025);

                //Mean
                GridMap(m,n) = (GridMap(m,n)*GridNum(m,n) + RobotPoint->points[i].y)/(GridNum(m,n) + 1);
                GridNum(m,n) = GridNum(m,n) + 1;

                //Max
                /*
        if (GridMap(m,n) < filtertransformed->points[i].y)
        {
            GridMap(m,n) = filtertransformed->points[i].y;
        }
        */
            }
        }
        //Judge Command

        float LeftHeight = 0, RightHeight = 0, MiddleHeight = 0;

        for(int i=40; i<=55; i++)
        {
            for(int j = 41;j<=53;j++)
            {
                if(GridMap(i,j)>=0.2)
                {
                    Obstacle = true;
                }
                else
                {
                    RightHeight = RightHeight + GridMap(i,j);
                }
            }
        }

        for(int i=40; i<=55; i++)
        {
            for(int j = 54;j<=66;j++)
            {
                if(GridMap(i,j)>=0.2)
                {
                    Obstacle = true;
                }
                else
                {
                    MiddleHeight = MiddleHeight + GridMap(i,j);
                }
            }
        }

        for(int i=40; i<=55; i++)
        {
            for(int j = 67;j<=79;j++)
            {
                if(GridMap(i,j)>=0.2)
                {
                    Obstacle = true;
                }
                else
                {
                    LeftHeight = LeftHeight + GridMap(i,j);
                }
            }
        }

        if(Obstacle == false)
        {
            ControlCommand = NoValidCommand;
            cout<<"Robot Safe!!!"<<endl;
        }
        if(Obstacle == true)
        
            if(LeftHeight>=RightHeight&&LeftHeight>=MiddleHeight)
            {
                ControlCommand = TurnLeft;
                cout<<"Send Turn Right!!!"<<endl;
            }
            if(RightHeight>=LeftHeight&&RightHeight>=MiddleHeight)
            {
                ControlCommand = TurnRight;
                cout<<"Send Turn Left!!!"<<endl;
            }
            if(MiddleHeight>=LeftHeight&&MiddleHeight>=RightHeight)
            {
                ControlCommand = MoveForward;
                cout<<"Send Move Backward!!!"<<endl;
            }

        }

        std::stringstream out;
        out<<frames_num;
        std::string filename = "GridMap" + out.str() + ".txt";
        std::ofstream Gridmapfile(filename);
        if (Gridmapfile.is_open())
        {
            Gridmapfile<<GridMap<<endl;
        }

        IsCaptureEnd = true;
    }
}

void Kinect::viewcloud()
{
    boost::function<void (const pcl::PointCloud<pcl::PointXYZ>::ConstPtr&)> f =
            boost::bind (&Kinect::pointcloud, this, _1);

    interface->registerCallback (f);
}

void Kinect::stop()
{
    interface->stop();
}
